<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mafia AI ‚Äì Control Panel</title>
    <style>
      :root {
        --bg: #0b1220;
        --panel: #0f172a;
        --muted: #94a3b8;
        --text: #e2e8f0;
        --accent: #7c3aed;
        --green: #16a34a;
        --blue: #2563eb;
        --card: #0b1730;
        --border: #1e293b;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji; background: linear-gradient(180deg, #0b1220, #0b0f1a 40%, #0a0d18); color: var(--text); }
      .container { max-width: 1040px; margin: 24px auto; padding: 0 16px; }
      h1 { font-size: 22px; margin: 0 0 16px; letter-spacing: 0.3px; }
      .grid { display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 16px; }
      .panel { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.25); }
      .title { display:flex; align-items:center; justify-content:space-between; margin-bottom: 10px; }
      .title h2 { font-size: 15px; margin: 0; color: #e5e7eb; opacity: .95; }
      label { font-size: 12px; color: var(--muted); }
      input[type=text], input[type=number] { width: 100%; background: #0b1730; border: 1px solid var(--border); color: var(--text); outline: none; padding: 8px 10px; border-radius: 8px; }
      input[type=file] { color: var(--muted); }
      .row { display:flex; gap:10px; align-items:center; margin: 6px 0; }
      .btn { background: #131c33; border: 1px solid var(--border); color: #dbeafe; padding: 8px 12px; border-radius: 8px; cursor: pointer; transition: transform .06s ease, background .2s ease; }
      .btn.primary { background: radial-gradient(1000px 80px at 50% -120px, rgba(124,58,237,.25), transparent 70%), #1f2937; border-color: #3b82f6; }
      .btn:active { transform: translateY(1px); }
      .switch { display:flex; align-items:center; gap:8px; }
      .status { font-size: 12px; color: var(--muted); }
      .timeline { display: grid; gap: 8px; }
      .phase { background: linear-gradient(180deg, #0b1730, #0b1324); border: 1px solid var(--border); border-radius: 12px; padding: 10px; transform: translateY(6px); opacity: 0; animation: rise .35s ease forwards; overflow: hidden; }
      .phaseHead { height: 6px; border-radius: 10px 10px 0 0; margin: -10px -10px 8px -10px; position: relative; overflow: hidden; }
      .phaseHead::after { content: ""; position: absolute; inset: 0; background-size: 200% 100%; animation: shimmer 2.5s linear infinite; opacity: .8; }
      .phaseHead.day { background: linear-gradient(90deg, #fde68a 0%, #f59e0b 50%, #fde68a 100%); }
      .phaseHead.day::after { background-image: linear-gradient(90deg, transparent, rgba(255,255,255,.25), transparent); }
      .phaseHead.night { background: linear-gradient(90deg, #1e3a8a 0%, #0ea5e9 50%, #1e3a8a 100%); }
      .phaseHead.night::after { background-image: linear-gradient(90deg, transparent, rgba(255,255,255,.15), transparent); }
      .phase .meta { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
      .phase.day { box-shadow: inset 0 0 0 1px rgba(22,163,74,.25); }
      .phase.night { box-shadow: inset 0 0 0 1px rgba(37,99,235,.25); }
      .msg { display:grid; grid-template-columns: 40px 1fr auto; gap:10px; align-items:center; background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 8px; transform: translateY(6px); opacity:0; animation: pop .25s ease forwards; }
      .agent { font-weight: 600; color:#e5e7eb; display:flex; align-items:center; gap:8px; }
      .avatar { width: 32px; height: 32px; border-radius: 999px; display: inline-flex; align-items: center; justify-content: center; color: #fff; font-weight: 800; letter-spacing: .3px; border: 1px solid rgba(255,255,255,.06); box-shadow: 0 6px 14px rgba(0,0,0,.25) inset; font-size: 12px; }
      .bubble { background: #0c1a37; border: 1px solid #0f2549; padding: 8px 10px; border-radius: 8px; }
      .actions { opacity: 0; transition: opacity .15s ease; }
      .msg:hover .actions { opacity: 1; }
      .chip { display:inline-flex; align-items:center; gap:6px; font-size: 11px; color: var(--muted); padding:4px 8px; border-radius:999px; border:1px solid var(--border); background:#0b1324; }
      .chip .dot { width:8px; height:8px; border-radius:999px; display:inline-block; background:#475569; }
      .chip.ok .dot { background: var(--green); }
      .chip.wait .dot { background: var(--muted); animation: pulse 1.2s infinite ease-in-out; }
      .chip.speaking { border-color: #60a5fa; box-shadow: 0 0 0 1px rgba(96,165,250,.25), 0 0 12px rgba(96,165,250,.25) inset; color:#e2e8f0; }
      .chip .model { margin-left:6px; color:#93c5fd; opacity:.9; }
      .spinner { width: 12px; height: 12px; border: 2px solid rgba(255,255,255,.2); border-top-color: #60a5fa; border-radius: 50%; animation: spin .8s linear infinite; }
      .chip.majority { border-color: #22c55e; box-shadow: 0 0 0 1px rgba(34,197,94,.35), 0 0 14px rgba(34,197,94,.25) inset; color:#eaffea; }
      @keyframes blinkMajority { 0%,100% { opacity: .8 } 50% { opacity: 1 } }
      .dead { opacity:.5; text-decoration: line-through; }
      .list { display:flex; flex-wrap: wrap; gap:6px; }
      .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color:#93c5fd; }
      .footer { margin-top:8px; display:flex; justify-content:space-between; align-items:center; }
      audio { width: 100%; }
      pre { background:#0a1020; border:1px solid var(--border); border-radius:10px; padding:8px; color:#93c5fd; max-height:240px; overflow:auto; }
      @keyframes pop { from { opacity:0; transform: translateY(12px) scale(.98);} to { opacity:1; transform: translateY(0) scale(1);} }
      @keyframes rise { from { opacity:0; transform: translateY(12px);} to { opacity:1; transform: translateY(0);} }
      @keyframes pulse { 0%,100% { transform: scale(1); opacity:.6 } 50% { transform: scale(1.25); opacity:1 } }
      @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }
      @keyframes spin { to { transform: rotate(360deg); } }
      @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    </style>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div class="container">
      <h1>Mafia AI ‚Äì Control Panel</h1>
      <div id="root"></div>
    </div>
    <script type="text/babel" data-presets="react">
      const { useEffect, useRef, useState } = React;

      const AGENT_META = {
        'gpt-5.2': { color: '#f59e0b', emoji: 'ü§ñ' },
        'claude-4.5-opus': { color: '#06b6d4', emoji: 'üß†' },
        'sonnet-4.5': { color: '#a855f7', emoji: 'üé≠' },
        'llama-4': { color: '#84cc16', emoji: 'ü¶ô' },
        'mixtral-8x22b': { color: '#f97316', emoji: 'üß™' },
        'mistral': { color: '#22d3ee', emoji: 'üí†' },
        'deepseek-r1': { color: '#ef4444', emoji: 'üîé' },
        'deepseek-v3.2': { color: '#eab308', emoji: 'üõ∞Ô∏è' },
        'glm-4.7': { color: '#60a5fa', emoji: 'üêâ' },
      };

      function hashColor(name) { let h = 0; for (let i=0;i<name.length;i++) { h = (h<<5)-h + name.charCodeAt(i); h|=0; } const hue = Math.abs(h)%360; return `hsl(${hue} 70% 45%)`; }
      function getAgentMeta(name) { return AGENT_META[name] || { color: hashColor(name), emoji: name.slice(0,1).toUpperCase() }; }

      

      function useAudioQueue(onStart, onEnd) {
        const audioRef = useRef(new Audio());
        const queueRef = useRef([]);
        const playingRef = useRef(false);

        const playBlob = (blob) => new Promise(async (resolve) => {
          const url = URL.createObjectURL(blob);
          const audio = audioRef.current;
          audio.src = url;
          const done = () => { audio.onended = null; audio.onerror = null; resolve(); };
          audio.onended = done; audio.onerror = done;
          try { await audio.play(); } catch { done(); }
        });

        const enqueue = (fn) => {
          queueRef.current.push(fn);
          if (!playingRef.current) process();
        };

        const process = async () => {
          playingRef.current = true;
          while (queueRef.current.length) {
            const fn = queueRef.current.shift();
            try {
              const result = await fn();
              if (result) {
                const { blob, meta } = result.blob ? result : { blob: result, meta: undefined };
                if (onStart) try { onStart(meta); } catch {}
                if (blob) await playBlob(blob);
                if (onEnd) try { onEnd(meta); } catch {}
              }
            } catch { /* ignore */ }
          }
          playingRef.current = false;
        };

        return { enqueue };
      }

      function App() {
        const qp = new URLSearchParams(location.search);
        const deriveDefaultApiBase = () => {
          const fromQ = qp.get('api');
          if (fromQ) return fromQ;
          const proto = location.protocol;
          const host = location.hostname;
          const port = '8000';
          return `${proto}//${host}:${port}`;
        };
        const deriveDefaultWsUrl = (base) => {
          const fromQ = qp.get('ws');
          if (fromQ) return fromQ;
          try {
            const u = new URL(base);
            const wsProto = u.protocol === 'https:' ? 'wss:' : 'ws:';
            return `${wsProto}//${u.hostname}:${u.port||'8000'}/ws/game`;
          } catch { return 'ws://localhost:8000/ws/game'; }
        };

        const [apiBase, setApiBase] = useState(deriveDefaultApiBase());
        const [wsUrl, setWsUrl] = useState(deriveDefaultWsUrl(deriveDefaultApiBase()));
        const [rounds, setRounds] = useState(10);
        const [timeoutS, setTimeoutS] = useState(60);
        const [autoTts, setAutoTts] = useState(true);
        const [status, setStatus] = useState('Disconnected');
        const [phases, setPhases] = useState([]);
        const [countdown, setCountdown] = useState({ kind: null, remaining_s: 0 });
        const [models, setModels] = useState(null);
        const [priv, setPriv] = useState({ mafia: [] });
        const [dayStatus, setDayStatus] = useState({ votes: {}, tally: {}, threshold: 0 });
        const [mafiaStatus, setMafiaStatus] = useState({ mafia: [], alive_mafia: [], votes: {}, kills: {}, remaining_s: 0 });
        const [asr, setAsr] = useState(null);
        const [dead, setDead] = useState([]);
        const [ttsText, setTtsText] = useState('Hello from the Mafia control panel');
        const [adminMode, setAdminMode] = useState(false);
        const [asrFile, setAsrFile] = useState(null);
        const [legendAgents, setLegendAgents] = useState([]);
        const wsRef = useRef(null);
        const reconnectRef = useRef(null);
        const [nowSpeaking, setNowSpeaking] = useState(null);
        const { enqueue } = useAudioQueue((meta)=>setNowSpeaking(meta||null), ()=>setNowSpeaking(null));

        useEffect(() => { (async () => { try { const r = await fetch(`${apiBase}/settings`); const s = await r.json(); setTimeoutS(s.agent_timeout_s ?? 6); } catch {} })(); }, [apiBase]);

        const connect = () => {
          if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN) return;
          const ws = new WebSocket(wsUrl);
          wsRef.current = ws;
          setStatus('Connecting...');
          ws.onopen = () => { setStatus('Connected'); if (reconnectRef.current) { clearTimeout(reconnectRef.current); reconnectRef.current = null; } };
          ws.onclose = () => {
            setStatus('Disconnected');
            if (!reconnectRef.current) {
              reconnectRef.current = setTimeout(() => { reconnectRef.current = null; connect(); }, 1500);
            }
          };
          ws.onerror = () => setStatus('Error');
          ws.onmessage = (m) => { try { handle(JSON.parse(m.data)); } catch {} };
        };
        useEffect(() => { connect(); /* autoconnect on url change */ return () => { if (reconnectRef.current) { clearTimeout(reconnectRef.current); reconnectRef.current = null; } } }, [wsUrl]);

        const start = () => {
          if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return alert('Connect first');
          setPhases([]);
          wsRef.current.send(JSON.stringify({ type: 'start', rounds: Number(rounds)||1 }));
        };

        const applySettings = async () => {
          try { await fetch(`${apiBase}/settings`, { method: 'POST', headers: {'content-type':'application/json'}, body: JSON.stringify({ agent_timeout_s: Number(timeoutS)||6 })}); } catch {}
        };

        function handle(msg) {
          if (msg.type === 'phase') {
            setPhases(prev => [...prev, { name: msg.name, index: msg.index, agents: msg.agents||[], messages: [], events: [] }]);
            setCountdown({ kind: msg.name, remaining_s: 0 });
            if (Array.isArray(msg.agents)) setLegendAgents(msg.agents);
          } else if (msg.type === 'agent_message') {
            setPhases(prev => {
              if (!prev.length) return prev;
              const copy = prev.slice();
              copy[copy.length-1] = { ...copy[copy.length-1], messages: [...copy[copy.length-1].messages, { agent: msg.agent, text: msg.text }] };
              return copy;
            });
            if (autoTts && msg.text) enqueueSpeak(msg.text, msg.agent);
          } else if (msg.type === 'event' && msg.name === 'night_result') {
            setPhases(prev => {
              if (!prev.length) return prev;
              const copy = prev.slice();
              const last = copy[copy.length-1];
              const events = (last.events || []).concat([{ type: 'night_result', victim: msg.victim || null }]);
              copy[copy.length-1] = { ...last, events };
              return copy;
            });
            if (msg.victim) setDead(prev => prev.includes(msg.victim) ? prev : [...prev, msg.victim]);
          } else if (msg.type === 'private_message') {
            setPriv(prev => {
              const chan = msg.channel || 'mafia';
              const next = { ...prev };
              const list = next[chan] || [];
              next[chan] = [...list, { agent: msg.agent, text: msg.text }];
              return next;
            });
            if (autoTts && msg.text) enqueueSpeak(msg.text, msg.agent);
          } else if (msg.type === 'day_status') {
            setCountdown({ kind: 'day', remaining_s: Math.max(0, Math.round(msg.remaining_s||0)) });
            setDayStatus({ votes: msg.votes||{}, tally: msg.tally||{}, threshold: msg.threshold||0 });
          } else if (msg.type === 'mafia_status') {
            setMafiaStatus({
              mafia: msg.mafia || [],
              alive_mafia: msg.alive_mafia || [],
              votes: msg.votes || {},
              kills: msg.kills || {},
              remaining_s: Math.max(0, Math.round((msg.remaining_s || 0)))
            });
            setCountdown({ kind: 'night', remaining_s: Math.max(0, Math.round((msg.remaining_s || 0))) });
          } else if (msg.type === 'event' && msg.name === 'day_result') {
            setPhases(prev => {
              if (!prev.length) return prev;
              const copy = prev.slice();
              const last = copy[copy.length-1];
              const events = (last.events || []).concat([{ type: 'day_result', victim: msg.victim || null, votes: msg.votes || {} }]);
              copy[copy.length-1] = { ...last, events };
              return copy;
            });
            if (msg.victim) setDead(prev => prev.includes(msg.victim) ? prev : [...prev, msg.victim]);
          }
        }

        async function speak(text) {
          const r = await fetch(`${apiBase}/tts/speak`, { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify({ text }) });
          return await r.blob();
        }

        function enqueueSpeak(text, agent) {
          enqueue(async () => ({ blob: await speak(text), meta: { agent, text } }));
        }

        async function doTranscribe() {
          if (!asrFile) return; const fd = new FormData(); fd.append('file', asrFile);
          const r = await fetch(`${apiBase}/asr/transcribe`, { method: 'POST', body: fd }); setAsr(await r.json());
        }

        async function loadModels() { const r = await fetch(`${apiBase}/agents/models`); setModels(await r.json()); }
        useEffect(()=>{ loadModels().catch(()=>{}); }, [apiBase]);
        function getModelFor(name) { const list = models?.agents || []; const found = list.find(a => a.name === name); return found?.openrouter_model || null; }

        // Messages are rendered as-is to keep human-like phrasing.

        return (
          <div className="grid">
            <div className="panel">
              <div className="title"><h2>Connection & Settings</h2><div className="status">{status}</div></div>
              {nowSpeaking && (
                <div className="row" style={{alignItems:'center', marginTop: '6px'}}>
                  <div className="spinner"></div>
                  <div style={{fontSize:'13px'}}>
                    Now speaking: <strong>{nowSpeaking.agent}</strong>
                    {getModelFor(nowSpeaking.agent) && <span className="mono" style={{marginLeft:6}}>{getModelFor(nowSpeaking.agent)}</span>}
                  </div>
                </div>
              )}
              <div className="row">
                <label style={{flex:1}}>API Base<br/><input value={apiBase} onChange={e=>setApiBase(e.target.value)} type="text" /></label>
                <label style={{flex:1}}>WS URL<br/><input value={wsUrl} onChange={e=>setWsUrl(e.target.value)} type="text" /></label>
              </div>
              <div className="row">
                <label className="switch"><input type="checkbox" checked={adminMode} onChange={e=>setAdminMode(e.target.checked)} /> Admin Mode (show Detective/Doctor)</label>
              </div>
              <div className="row">
                <label>Rounds<br/><input value={rounds} onChange={e=>setRounds(e.target.value)} type="number" min={1} /></label>
                <label>Agent Timeout (s)<br/><input value={timeoutS} onChange={e=>setTimeoutS(e.target.value)} type="number" min={1} step={0.5} /></label>
                <label className="switch"><input type="checkbox" checked={autoTts} onChange={e=>setAutoTts(e.target.checked)} /> Auto TTS</label>
              </div>
              <div className="row">
                <button className="btn" onClick={connect}>Connect</button>
                <button className="btn" onClick={()=>wsRef.current?.close?.()}>Disconnect</button>
                <button className="btn primary" onClick={start}>Start</button>
                <button className="btn" onClick={applySettings}>Apply Settings</button>
              </div>
              <div className="title" style={{marginTop:10}}>
                <h2>Game Timeline</h2>
                {countdown.kind && <div className="mono" style={{opacity:.9}}>{countdown.kind==='day'?'üó£Ô∏è Day':'üåô Night'} ¬∑ {countdown.remaining_s}s</div>}
              </div>
              {countdown.kind==='day' && (
                <div className="list" style={{margin:'4px 0 8px'}}>
                  {(() => {
                    const thr = dayStatus.threshold||0;
                    let maj = null;
                    for (const [t,c] of Object.entries(dayStatus.tally||{})) { if (c >= thr && thr>0) { maj = t; break; } }
                    return maj ? (
                      <div className="mono" style={{color:'#86efac', marginBottom:4, animation:'blinkMajority 1.2s ease-in-out infinite'}}>Majority reached: <strong>{maj}</strong></div>
                    ) : (<div className="mono" style={{opacity:.8}}>Majority at {thr}</div>);
                  })()}
                  {Object.entries(dayStatus.tally||{}).map(([target,count])=> (
                    <div key={target} className={`chip ${count >= (dayStatus.threshold||0) && (dayStatus.threshold||0)>0 ? 'majority' : ''}`} title={`Votes: ${count}`}>
                      <span className="dot"></span>
                      <span>{target}</span>
                      <span className="model mono">{count}/{dayStatus.threshold||0}</span>
                    </div>
                  ))}
                  {(!dayStatus.tally || Object.keys(dayStatus.tally).length===0) && <div className="mono" style={{opacity:.7}}>No votes yet</div>}
                </div>
              )}
              <div className="timeline" id="timeline">
                {phases.map((p, idx)=> (
                  <div key={idx} className={`phase ${p.name}`}>
                    <div className={`phaseHead ${p.name}`}></div>
                    <div className="meta">{p.name === 'day' ? '‚òÄÔ∏è' : 'üåô'} Phase: <span className="mono">{p.name.toUpperCase()}</span> ‚Ä¢ Round <span className="mono">#{p.index}</span></div>
                    <div className="mono" style={{opacity:.7, marginBottom:6}}>Players: {p.agents?.length}</div>
                    {p.events && p.events.length > 0 && (
                      <div className="mono" style={{margin:'6px 0', color:'#fca5a5'}}>
                        {p.events.map((e,i)=> (
                          e.type==='night_result' ? <div key={i}>{e.victim ? <>Night kill: <strong>{e.victim}</strong></> : 'No one died'}</div>
                          : e.type==='night_saved' ? <div key={i} style={{color:'#86efac'}}>Saved: <strong>{e.target}</strong></div>
                          : e.type==='day_result' ? <div key={i}>{e.victim ? <>Lynched: <strong>{e.victim}</strong></> : 'No lynch'} {e.votes && Object.keys(e.votes).length ? <>¬∑ votes: {Object.entries(e.votes).map(([v,t])=>`${v}‚Üí${t}`).join(', ')}</> : null}</div>
                          : null
                        ))}
                      </div>
                    )}
                    <div className="stack" style={{display:'grid', gap:8}}>
                      {p.messages.map((m,i)=> {
                        const meta = getAgentMeta(m.agent);
                        const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (m.agent.slice(0,1).toUpperCase());
                        return (
                          <div key={i} className="msg">
                      <div className="agent"><span className="avatar" style={{background: meta.color}}>{letter}</span></div>
                            <div>
                              <div className="bubble">{m.text}</div>
                            </div>
                            <div className="actions"><button className="btn" onClick={()=>enqueueSpeak(m.text, m.agent)}>Speak</button></div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                ))}
              </div>
            </div>

            <div style={{display:'grid', gap:'16px'}}>
              <div className="panel">
                <div className="title"><h2>Legend</h2></div>
                <div className="list">
                  {legendAgents.length ? legendAgents.map(name => {
                    const meta = getAgentMeta(name);
                    const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (name.slice(0,1).toUpperCase());
                    return (
                      <div key={name} className="chip" title={name}>
                        <span className="dot" style={{background: meta.color}}></span>
                        <span style={{marginRight:6}}>{name}</span>
                        <span className="avatar" style={{background: meta.color}}>{letter}</span>
                      </div>
                    );
                  }) : <div className="mono" style={{opacity:.7}}>Legend appears after start</div>}
                </div>
              </div>
              <div className="panel">
                <div className="title"><h2>Graveyard</h2></div>
                <div className="list" style={{maxHeight:'180px', overflow:'auto'}}>
                  {dead.length ? dead.map(n => {
                    const meta = getAgentMeta(n);
                    return <div key={n} className="chip dead"><span className="dot" style={{background: meta.color}}></span>üíÄ {n}</div>
                  }) : <div className="mono" style={{opacity:.7}}>No deaths yet</div>}
                </div>
              </div>
              <div className="panel">
                <div className="title"><h2>Private Chats</h2></div>
                <div>
                  <div className="row" style={{justifyContent:'space-between'}}>
                    <h3 style={{margin:'4px 0', fontSize:'13px', color:'#c7d2fe'}}>Mafia</h3>
                    <div className="mono" style={{opacity:.9}}>Night remaining: {mafiaStatus.remaining_s}s</div>
                  </div>
                  <div className="list" style={{marginBottom:8}}>
                    {mafiaStatus.mafia.map(name => {
                      const meta = getAgentMeta(name);
                      const vote = mafiaStatus.votes?.[name];
                      const kill = mafiaStatus.kills?.[name];
                      const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (name.slice(0,1).toUpperCase());
                      return (
                        <div key={name} className="chip" title={vote || kill ? `VOTE:${vote||'-'} KILL:${kill||'-'}` : ''}>
                          <span className="dot" style={{background: meta.color}}></span>
                          <span>{name}</span>
                          {vote && <span className="model mono">V:{vote}</span>}
                          {kill && <span className="model mono" style={{color:'#fca5a5'}}>K:{kill}</span>}
                        </div>
                      );
                    })}
                  </div>
                  {(() => {
                    const alive = mafiaStatus.alive_mafia || [];
                    const kills = mafiaStatus.kills || {};
                    if (alive.length && alive.every(n => n in kills)) {
                      const set = new Set(alive.map(n => kills[n]));
                      if (set.size === 1) {
                        const target = [...set][0];
                        return <div className="mono" style={{color:'#86efac', marginBottom:8}}>Agreed target: <strong>{target}</strong></div>;
                      }
                    }
                    return null;
                  })()}
                  <div style={{display:'grid', gap:8}}>
                    {priv.mafia.map((m,i)=>{
                      const meta = getAgentMeta(m.agent);
                      const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (m.agent.slice(0,1).toUpperCase());
                      return (
                        <div key={i} className="msg">
                          <div className="agent"><span className="avatar" style={{background: meta.color}}>{letter}</span><span>{m.agent}</span></div>
                          <div className="bubble">{m.text}</div>
                      <div className="actions"><button className="btn" onClick={()=>enqueueSpeak(m.text, m.agent)}>Speak</button></div>
                        </div>
                      );
                    })}
                    {(!priv.mafia || priv.mafia.length===0) && <div className="mono" style={{opacity:.7}}>No messages yet</div>}
                  </div>
                  {adminMode && (
                    <>
                      <h3 style={{margin:'10px 0 4px', fontSize:'13px', color:'#c7d2fe'}}>Detective</h3>
                      <div style={{display:'grid', gap:8}}>
                        {(priv.detective||[]).map((m,i)=>{
                          const meta = getAgentMeta(m.agent);
                          const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (m.agent.slice(0,1).toUpperCase());
                          return (
                            <div key={i} className="msg">
                              <div className="agent"><span className="avatar" style={{background: meta.color}}>{letter}</span><span>{m.agent}</span></div>
                              <div className="bubble">{m.text}</div>
                              <div><button className="btn" onClick={()=>enqueueSpeak(m.text, m.agent)}>Speak</button></div>
                            </div>
                          );
                        })}
                        {(!priv.detective || priv.detective.length===0) && <div className="mono" style={{opacity:.7}}>No messages yet</div>}
                      </div>
                      <h3 style={{margin:'10px 0 4px', fontSize:'13px', color:'#c7d2fe'}}>Doctor</h3>
                      <div style={{display:'grid', gap:8}}>
                        {(priv.doctor||[]).map((m,i)=>{
                          const meta = getAgentMeta(m.agent);
                          const letter = (meta.emoji && meta.emoji.length<=2) ? meta.emoji : (m.agent.slice(0,1).toUpperCase());
                          return (
                            <div key={i} className="msg">
                              <div className="agent"><span className="avatar" style={{background: meta.color}}>{letter}</span><span>{m.agent}</span></div>
                              <div className="bubble">{m.text}</div>
                              <div><button className="btn" onClick={()=>enqueueSpeak(m.text, m.agent)}>Speak</button></div>
                            </div>
                          );
                        })}
                        {(!priv.doctor || priv.doctor.length===0) && <div className="mono" style={{opacity:.7}}>No messages yet</div>}
                      </div>
                    </>
                  )}
                </div>
              </div>
              <div className="panel">
                <div className="title"><h2>Speech</h2></div>
                <div className="row">
                  <label>Upload audio<br/><input type="file" onChange={e=>setAsrFile(e.target.files?.[0]||null)} /></label>
                  <button className="btn" onClick={doTranscribe}>Transcribe</button>
                </div>
                <pre>{asr ? JSON.stringify(asr, null, 2) : 'ASR result will appear here'}</pre>
                <div className="row">
                  <label>Say text<br/><input type="text" value={ttsText} onChange={e=>setTtsText(e.target.value)} /></label>
                  <button className="btn" onClick={()=>enqueueSpeak(ttsText)}>Speak</button>
                </div>
              </div>
            </div>
          </div>
        );
      }

      try {
        ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
      } catch (e) {
        const el = document.createElement('pre');
        el.textContent = 'UI failed to load: ' + (e && e.message ? e.message : e);
        document.body.appendChild(el);
        console.error(e);
      }
    </script>
  </body>
  </html>
